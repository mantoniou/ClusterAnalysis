---
title: "Segmentation of EU countries, based on consumer & business indicators"
description: "[Oct 27, 2018] Segmentation of EU countries, including cluster analysis based on consumer & business confidence indicators"
output: html_notebook
---



In this article i used a public Eurostat dataset, in order to develop a 
segmentation of the EU countries. 
This dataset consists of 5 confidence indicators:  

- **Consumer Confidence Indicator**  
- **Construction confidence indicator**  
- **Industrial confidence indicator**  
- **Retail confidence indicator**  
- **Services Confidence Indicator**  

These indicators are formed via qualitative surveys are conducted on a monthly 
basis in the following areas:
**manufacturing industry, construction, consumers, retail trade, services and financial services**. 
These surveys started in 1980 and gradually include all the new EU 
members. About 137,000 firms and more than 41,000 consumers are currently surveyed
every month across the EU. 

The used metrics is the balance i.e. the difference between positive and negative
answers (in percentage points of total answers), as index, as confidence indicators
(arithmetic average of balances).


More information about these surveys can be found at this 
[link](https://ec.europa.eu/eurostat/cache/metadata/en/ei_bcs_esms.htm)

The eurozone consists of 19 countries: Austria, Belgium, Cyprus, 
Estonia, Finland, France, Germany, Greece, Ireland, Italy, Latvia, Lithuania, 
Luxembourg, Malta, the Netherlands, Portugal, Slovakia, Slovenia, and Spain. 

The [Eurostat package](https://cran.r-project.org/web/packages/eurostat/index.html) 
used to obtain the original datasets.

More details about the ETL steps can be found, in the actual code, at the link 
at the end of the article.

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

# Libraries
library(tidyverse)
library(rvest)
library(eurostat)


```



```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
# Eurostat Business-Sentiment data ##############################################
dat <- get_eurostat("ei_bssi_m_r2", time_format = "date")
dat <- label_eurostat(dat)

sent <- 
  dat %>% 
  filter(s_adj == "Unadjusted data (i.e. neither seasonally adjusted nor calendar adjusted data)") %>% 
  select(geo, time, indic, values) %>% 
  spread(indic, values) %>% 
  rename(date = time) 

# Save the data
saveRDS(sent, file = "data/tidy/sent.RDS")
```



```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}

# Load the dataset
sent <- readRDS("/Users/manos/OneDrive/Projects/R/All_Projects/2018_10_ClusterAnalysis/data/tidy/sent.RDS") # Mac
# sent <- readRDS("C://Users//eam//OneDrive - Softone Technologies S.A//R_Help//clust//data//tidy//sent.RDS") # Win


# Only Consumer & business indicators
final <-
  sent %>%
  filter(date >= '2014-01-01') %>%
  select(-date) %>%
  group_by(geo) %>%
  summarise_all(median, na.rm = TRUE) %>% 
  mutate(Business = (`Construction confidence indicator` + `Industrial confidence indicator` +
           `Retail confidence indicator` + `Services Confidence Indicator`)/4,
         Consumers = `Consumer confidence indicator`) %>% 
  mutate(geo = recode(geo, 
                      "Germany (until 1990 former territory of the FRG)" = "Germany",
                      "Czech Republic" = "Czech Rep."))


```


# ETL & Exploratory Analysis

The original dataset consists of 11,340 observations that include these indicators
in some countries for a specific month. For the analysis i only used data from 
2014 onwards. In the processed dataset i used the median values of each variable 
in each country, so finally the dataset consists of 34 observations. One more 
variable was created, as the sum of all Business related confidence indicators 
(Construction, Industrial, Retail & Services Confidence Indicators), in order 
to have a genaral **business confidence indicator**.



```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

# Create Map data ##############################################################

library(grid)
library(rworldmap)


# Get the world map
worldMap <- getMap()

# Member States of the European Union
europeanUnion <- c("Austria","Belgium","Bulgaria","Croatia","Cyprus",
                   "Czech Rep.","Denmark","Estonia","Finland","France",
                   "Germany","Greece","Hungary","Ireland","Italy","Latvia",
                   "Lithuania","Luxembourg","Malta","Netherlands","Poland",
                   "Portugal","Romania","Slovakia","Slovenia","Spain",
                   "Sweden","United Kingdom")
# Select only the index of states member of the E.U.
indEU <- which(worldMap$NAME%in%europeanUnion)


# Extract longitude and latitude border's coordinates of members states of E.U. 
europeCoords <- lapply(indEU, function(i){
  df <- data.frame(worldMap@polygons[[i]]@Polygons[[1]]@coords)
  df$region =as.character(worldMap$NAME[i])
  colnames(df) <- list("long", "lat", "region")
  return(df)
})

europeCoords <- do.call("rbind", europeCoords)

```


It would be interesting to see the map plots of the confidence indicators. Below
there are plots with the aggregated business & consumer indicators 

```{r}
# Create table
europeanUnionTable <- data.frame(country = final$geo, value = final$Business)
europeCoords$value <- europeanUnionTable$value[match(europeCoords$region,europeanUnionTable$country)]


# Plot the map
ggplot() + 
  geom_polygon(data = europeCoords, aes(x = long, y = lat, group = region, fill = value),
                             colour = "black", size = 0.1) +
  coord_map(xlim = c(-13, 35),  ylim = c(32, 71)) + 
  scale_fill_gradient(name = "Business Confidence Indicator", low = "#FF0000FF", high = "#FFFF00FF", na.value = "grey50") +
  theme(axis.text.x = element_blank(),
  axis.text.y = element_blank(), axis.ticks.x = element_blank(),
  axis.ticks.y = element_blank(), axis.title = element_blank(),
  plot.margin = unit(0 * c(-1.5, -1.5, -1.5, -1.5), "lines")) + 
  scale_fill_gradient(name = "Business \nConfidence", low = "#FF0000FF", high = "#FFFF00FF", na.value = "grey50") +
  labs(title = "Business Confidence per EU country",
       subtitle = "-Median values of bus. conf. indicators for 2014-2018 \n-Red indicates low confidence & yellow indicates high ")+
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank())

```


```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

# Create table
europeanUnionTable <- data.frame(country = final$geo, value = final$Consumers)
europeCoords$value <- europeanUnionTable$value[match(europeCoords$region,europeanUnionTable$country)]


# Plot the map
ggplot() + 
  geom_polygon(data = europeCoords, aes(x = long, y = lat, group = region, fill = value),
                             colour = "black", size = 0.1) +
  coord_map(xlim = c(-13, 35),  ylim = c(32, 71)) + 
  scale_fill_gradient(name = "Consumers Confidence Indicator", low = "#FF0000FF", high = "#FFFF00FF", na.value = "grey50") +
  theme(axis.text.x = element_blank(),
  axis.text.y = element_blank(), axis.ticks.x = element_blank(),
  axis.ticks.y = element_blank(), axis.title = element_blank(),
  plot.margin = unit(0 * c(-1.5, -1.5, -1.5, -1.5), "lines")) + 
  scale_fill_gradient(name = "Consumer \nConfidence", low = "#FF0000FF", high = "#FFFF00FF", na.value = "grey50") +
  labs(title = "Consumers Confidence per EU country",
       subtitle = "-Median values of consumer conf. indicator for 2014-2018 \n-Red indicates low confidence & yellow indicates high")+
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank())


```

- It is clear that there are significant differences between countries.  
- Again, Nothern Europe countries tend to have higher consumers confidence 
indicators.  
- It seems that there are outlies here. Greece has significantly lower confidence indicator
than the rest of the countries. 


Below there is a scatterplot with marker labels indicating the positioning of 
each country in respect to consumer and confidence indicators. The overall 
business confidence indicator is the average of all business related features 
(Construction confidence indicator, Industrial confidence indicator, Retail 
confidence indicator & Services Confidence Indicator)

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
library(ggthemes)

filter(final, geo %in% europeanUnion) %>% 
ggplot(aes(Consumers, Business)) +
  geom_point()+
  geom_text(aes(label = geo), check_overlap = TRUE, vjust = 1, hjust = 1) +
  theme_fivethirtyeight() +
  theme(axis.title = element_text()) +
  labs(x = "Consumer Confidence",
       y = "Business Confidence",
       title = "Scatterplot of EU countries confidence levels",
       subtitle = "Data from 2014-2018") 

```

We can indicate some patterns from the plot above, similar to the findings before:   
- There are some outliers, such as Greece(bottom left) & Sweden(top right)  
- There is a group of countries that are placed in the middle of the plot, indicating
average consumer & business confidence 
- In all countries the business confidence is substantially higher than
consumer confidence


# Segmentation

There are quite a few differences between countries regarding 
confidence indicators. It would be very interesting to develop a segmentation, in
order to check how well the countries are forming teams.  
The **k-means** algorithm used for the segmentation. 
It is the widest used unsupervised learning algorithm. The procedure follows
a simple and easy way to classify a given data set through a certain number of 
clusters (assume k clusters) fixed apriori. The main idea is to define k centers,
one for each cluster. These centers should be placed in a cunning way because of
different location causes different result. So, the better choice is to place
them as much as possible far away from each other. The next step is to take each 
point belonging to a given data set and associate it to the nearest center. When 
no point is pending, the first step is completed and an early group age is done. 
At this point we need to re-calculate k new centroids as barycenter of the clusters
resulting from the previous step. After we have these k new centroids, a new 
binding has to be done between the same data set points and the nearest new center.
A loop has been generated. As a result of this loop we may notice that the k 
centers change their location step by step until no more changes are done or in 
other words centers do not move any more.


## Indicate suitable number of clusters

The elbow (scree) plot below, is used to check for the suitable number of clusters. 
So what we are looking for, is the point at which the curve in the plot begins
to flatten out. 


In detail, the total within cluster sum of squares is calculated (the sum of 
euclidean distances between each observation and the centroid corresponding to 
the cluster to which the observation is assigned). 


```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
library(purrr)
library(cluster)


kmeans.dat <- dist(scale(final[, 2:6]))

# Use map_dbl to run many models with varying value of k (centers)
tot_withinss <- map_dbl(1:10,  function(k){
  model <- kmeans(x = kmeans.dat, centers = k)
  model$tot.withinss
})

# Generate a data frame containing both k and tot_withinss
elbow_df <- data.frame(
  k = 1:10,
  tot_withinss = tot_withinss
)


ggplot(elbow_df, aes(x = k, y = tot_withinss)) +
  geom_line() +
  scale_x_continuous(breaks = 1:10) +
  theme_fivethirtyeight() +
  theme(axis.title = element_text()) +
  labs(y = "Total within sum of squares",
       x = "Number of clusters",
       title = "Elbow (scree) plot",
       subtitle = "Check optimal number of clusters")



```


**Silhouette analysis**

In general, silhouette analysis determines how well each of the observations fit into 
corresponding cluster (Higher is better).

It involves calculating a measurement called the silhouette width for every 
observation:  
- A value close to 1 suggests that this observation is well matched to its current cluster.  
- A value of 0 suggests that it is on the border between two clusters and can possibly 
belong to either one.  
- A value close to -1 suggests that the observation has a better fit to its 
closest neighboring cluster.



```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

library(purrr)
library(cluster)
# Use map_dbl to run many models with varying value of k
sil_width <- map_dbl(2:10,  function(k){
  model <- pam(x = kmeans.dat, k = k)
  model$silinfo$avg.width
})

# Generate a data frame containing both k and sil_width
sil_df <- data.frame(
  k = 2:10,
  sil_width = sil_width
)

# Plot the relationship between k and sil_width
ggplot(sil_df, aes(x = k, y = sil_width)) +
  geom_line() +
  scale_x_continuous(breaks = 2:10)+
  theme_fivethirtyeight() +
  theme(axis.title = element_text()) +
  labs(y = "Average Silhouette width",
       x = "Number of clusters",
       title = "Silhouette Analysis")

```

Although the silhouette value of the two clusters is the highest, four clusters
were chosen for a few reasons:  
- It is close to the highest value  
- From the elbow plot, it seems that the curve is flatten out after cluster 4  
- Two clusters are very few to represent differences in EU countries 



Below there is a table with **information about all clusters**, indicating the 
mean value of each confidence indicator within the cluster


```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
set.seed(42)

# Build a k-means model for the customers_spend with a k of 2
model_customers <- kmeans(kmeans.dat, centers = 4)

# Extract the vector of cluster assignments from the model
clust_countries <- model_customers$cluster

# Build the segment_customers dataframe
segment_countries <- 
  mutate(final[1:6], cluster = clust_countries) %>% 
  mutate(cluster = recode(cluster, 
                             "1" = "A",
                             "2" = "B",
                             "3" = "D",
                             "4" = "C")) 

library(DT)
# Calculate the mean for each category
segment_countries %>% 
  group_by(cluster) %>% 
  # summarise_all(funs(round(mean(.),2))) %>% 
  # datatable(filter = 'top', options = list(autoWidth = TRUE))
  add_tally() %>% 
  summarise_each(funs(round(mean(., na.rm = TRUE),2))) %>% 
  select(1, "n", 3:ncol(final)) %>% 
  datatable(filter = 'top', options = list(pageLength = 5, autoWidth = TRUE, dom = 'pt'))


```

- ?????????????  
- ??????????????  
- ?????????????

## Principal components
It would be nice to plot these clustering results and check these out visually. 
But it is impossible to visualise so many variables, as various dimensions are
required. 
One way to overame this, is to use some dimensionality reduction technique. In 
particular, PCA (principal components analysis) is used.  
It finds structure in features and aid in visualization.  
In particular:     
- It will find linear combination of variables to create principal components (new features)    
- Maintain most variance in the data    
- Principal components (new features) are uncorrelated (i.e. orthogonal to each other)

The plot below (biplot) shows all the original observations plotted on the first
2 principal components. 
        
```{r}

pca_soft <- prcomp(scale(kmeans.dat))

library(ggord)

ggord(pca_soft, segment_countries$cluster, ellipse = FALSE, hull = TRUE, arrow = 1, vec_ext = 3, veccol = 'red', veclsz = 1) +
  labs(title = "Biplot of principal components analysis",
       subtitle = "Check how well the clusters are separated")

```

- The A cluster is clearly stands out from the rest of the clusters  
- Clusters B & C are ovelapped to some extend  
- Cluster D (Greece) is clearly stands out from the rest

It can be said, that clusters B & C could either considered as "close related" or
even form a wider cluster since the differences are small. 

```{r}
# Create table with results
europeanUnionTable <- data.frame(country = segment_countries$geo, value = factor(segment_countries$cluster))
europeCoords$value <- europeanUnionTable$value[match(europeCoords$region,europeanUnionTable$country)]


# Plot the map
ggplot() + 
  geom_polygon(data = europeCoords, aes(x = long, y = lat, group = region, fill = value),
                             colour = "black", size = 0.1) +
  coord_map(xlim = c(-13, 35),  ylim = c(32, 71))+ 
  theme(
  axis.text.x = element_blank(),
  axis.text.y = element_blank(), axis.ticks.x = element_blank(),
  axis.ticks.y = element_blank(), axis.title = element_blank(),
  plot.margin = unit(0 * c(-1.5, -1.5, -1.5, -1.5), "lines")) + 
  labs(title = "Clusters in EU (based on confidence indicators)",
       subtitle = "",
       fill = "Cluster")+
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank()) +
   scale_fill_manual(values=c("#33A02C", "#FFA100", "#F7CE68", "#E31A1C"))

```

- Cluster A are the EU countries with the higher confidence  
- Cluster B are above average in confidence  
- Cluster C are below average  
- Cluster D (Greece) has extremely low confidence 


Below there is a table of all EU countries indicating their cluster.

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

library(DT)
# Print the table with 
segment_countries %>% 
  select(c(1, "cluster", 2:6)) %>% 
  datatable(filter = 'top', options = list(pageLength = 10, autoWidth = TRUE, dom = 'pt'))

```

